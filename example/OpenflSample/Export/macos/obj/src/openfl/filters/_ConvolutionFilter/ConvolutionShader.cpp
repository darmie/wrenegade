// Generated by Haxe 4.0.0-rc.2+77068e1
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Bool
#include <openfl/display/ShaderParameter_Bool.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_openfl_filters_BitmapFilterShader
#include <openfl/filters/BitmapFilterShader.h>
#endif
#ifndef INCLUDED_openfl_filters__ConvolutionFilter_ConvolutionShader
#include <openfl/filters/_ConvolutionFilter/ConvolutionShader.h>
#endif
#ifndef INCLUDED_openfl_utils_ByteArrayData
#include <openfl/utils/ByteArrayData.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataInput
#include <openfl/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataOutput
#include <openfl/utils/IDataOutput.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_5054037a2bd70aa6_347_new,"openfl.filters._ConvolutionFilter.ConvolutionShader","new",0x1c2c8ac3,"openfl.filters._ConvolutionFilter.ConvolutionShader.new","openfl/filters/ConvolutionFilter.hx",347,0x8cb91f21)
static const Float _hx_array_data_f8416d51_1[] = {
	(Float)1,
};
static const Float _hx_array_data_f8416d51_2[] = {
	(Float)0,
};
static const bool _hx_array_data_f8416d51_3[] = {
	1,
};
namespace openfl{
namespace filters{
namespace _ConvolutionFilter{

void ConvolutionShader_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_5054037a2bd70aa6_347_new)
HXLINE( 182)		if (hx::IsNull( this->_hx___glFragmentSource )) {
HXLINE( 184)			this->_hx___glFragmentSource = HX_("varying vec2 vBlurCoords[9];\n\n\t\tuniform sampler2D openfl_Texture;\n\n\t\tuniform float uBias;\n\t\tuniform mat3 uConvoMatrix;\n\t\tuniform float uDivisor;\n\t\tuniform bool uPreserveAlpha;\n\n\t\tvoid main(void) {\n\n\t\t\tvec4 tc = texture2D (openfl_Texture, vBlurCoords[4]);\n\t\t\tvec4 c = vec4 (0.0);\n\n\t\t\tc += texture2D (openfl_Texture, vBlurCoords[0]) * uConvoMatrix[0][0];\n\t\t\tc += texture2D (openfl_Texture, vBlurCoords[1]) * uConvoMatrix[0][1];\n\t\t\tc += texture2D (openfl_Texture, vBlurCoords[2]) * uConvoMatrix[0][2];\n\n\t\t\tc += texture2D (openfl_Texture, vBlurCoords[3]) * uConvoMatrix[1][0];\n\t\t\tc += tc * uConvoMatrix[1][1];\n\t\t\tc += texture2D (openfl_Texture, vBlurCoords[5]) * uConvoMatrix[1][2];\n\n\t\t\tc += texture2D (openfl_Texture, vBlurCoords[6]) * uConvoMatrix[2][0];\n\t\t\tc += texture2D (openfl_Texture, vBlurCoords[7]) * uConvoMatrix[2][1];\n\t\t\tc += texture2D (openfl_Texture, vBlurCoords[8]) * uConvoMatrix[2][2];\n\n\t\t\tif (uDivisor > 0.0) {\n\n\t\t\t\tc /= vec4 (uDivisor, uDivisor, uDivisor, uDivisor);\n\n\t\t\t}\n\n\t\t\tc += vec4 (uBias, uBias, uBias, uBias);\n\n\t\t\tif (uPreserveAlpha) {\n\n\t\t\t\tc.a = tc.a;\n\n\t\t\t}\n\n\t\t\tgl_FragColor = c;\n\n\t\t}",c3,d5,b1,c7);
            		}
HXLINE( 174)		if (hx::IsNull( this->_hx___glVertexSource )) {
HXLINE( 176)			this->_hx___glVertexSource = HX_("attribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\n\t\tvarying vec2 vBlurCoords[9];\n\n\t\tuniform mat4 openfl_Matrix;\n\t\tuniform vec2 openfl_TextureSize;\n\n\t\tvoid main(void) {\n\n\t\t\tvec2 r = vec2 (1.0, 1.0) / openfl_TextureSize;\n\t\t\tvec2 t = openfl_TextureCoord;\n\n\t\t\tvBlurCoords[0] = t + r * vec2 (-1.0, -1.0);\n\t\t\tvBlurCoords[1] = t + r * vec2 (0.0, -1.0);\n\t\t\tvBlurCoords[2] = t + r * vec2 (1.0, -1.0);\n\n\t\t\tvBlurCoords[3] = t + r * vec2 (-1.0, 0.0);\n\t\t\tvBlurCoords[4] = t;\n\t\t\tvBlurCoords[5] = t + r * vec2 (1.0, 0.0);\n\n\t\t\tvBlurCoords[6] = t + r * vec2 (-1.0, 1.0);\n\t\t\tvBlurCoords[7] = t + r * vec2 (0.0, 1.0);\n\t\t\tvBlurCoords[8] = t + r * vec2 (1.0, 1.0);\n\n\t\t\tgl_Position = openfl_Matrix * openfl_Position;\n\n\t\t}",cd,5f,8f,34);
            		}
HXLINE( 348)		super::__construct(null());
HXLINE( 351)		this->uDivisor->value = ::Array_obj< Float >::fromData( _hx_array_data_f8416d51_1,1);
HXLINE( 352)		this->uBias->value = ::Array_obj< Float >::fromData( _hx_array_data_f8416d51_2,1);
HXLINE( 353)		this->uPreserveAlpha->value = ::Array_obj< bool >::fromData( _hx_array_data_f8416d51_3,1);
HXLINE( 273)		this->_hx___isGenerated = true;
HXDLIN( 273)		this->_hx___initGL();
            	}

Dynamic ConvolutionShader_obj::__CreateEmpty() { return new ConvolutionShader_obj; }

void *ConvolutionShader_obj::_hx_vtable = 0;

Dynamic ConvolutionShader_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ConvolutionShader_obj > _hx_result = new ConvolutionShader_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ConvolutionShader_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2df4abed) {
		if (inClassId<=(int)0x03978973) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x03978973;
		} else {
			return inClassId==(int)0x2df4abed;
		}
	} else {
		return inClassId==(int)0x676ab1f7;
	}
}


hx::ObjectPtr< ConvolutionShader_obj > ConvolutionShader_obj::__new() {
	hx::ObjectPtr< ConvolutionShader_obj > __this = new ConvolutionShader_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< ConvolutionShader_obj > ConvolutionShader_obj::__alloc(hx::Ctx *_hx_ctx) {
	ConvolutionShader_obj *__this = (ConvolutionShader_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(ConvolutionShader_obj), true, "openfl.filters._ConvolutionFilter.ConvolutionShader"));
	*(void **)__this = ConvolutionShader_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

ConvolutionShader_obj::ConvolutionShader_obj()
{
}

void ConvolutionShader_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ConvolutionShader);
	HX_MARK_MEMBER_NAME(uBias,"uBias");
	HX_MARK_MEMBER_NAME(uConvoMatrix,"uConvoMatrix");
	HX_MARK_MEMBER_NAME(uDivisor,"uDivisor");
	HX_MARK_MEMBER_NAME(uPreserveAlpha,"uPreserveAlpha");
	 ::openfl::filters::BitmapFilterShader_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ConvolutionShader_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(uBias,"uBias");
	HX_VISIT_MEMBER_NAME(uConvoMatrix,"uConvoMatrix");
	HX_VISIT_MEMBER_NAME(uDivisor,"uDivisor");
	HX_VISIT_MEMBER_NAME(uPreserveAlpha,"uPreserveAlpha");
	 ::openfl::filters::BitmapFilterShader_obj::__Visit(HX_VISIT_ARG);
}

hx::Val ConvolutionShader_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"uBias") ) { return hx::Val( uBias ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"uDivisor") ) { return hx::Val( uDivisor ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"uConvoMatrix") ) { return hx::Val( uConvoMatrix ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"uPreserveAlpha") ) { return hx::Val( uPreserveAlpha ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val ConvolutionShader_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"uBias") ) { uBias=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"uDivisor") ) { uDivisor=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"uConvoMatrix") ) { uConvoMatrix=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"uPreserveAlpha") ) { uPreserveAlpha=inValue.Cast<  ::openfl::display::ShaderParameter_Bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ConvolutionShader_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("uBias",8e,f5,d1,89));
	outFields->push(HX_("uConvoMatrix",27,06,24,20));
	outFields->push(HX_("uDivisor",69,15,42,62));
	outFields->push(HX_("uPreserveAlpha",3d,d2,3a,39));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo ConvolutionShader_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(ConvolutionShader_obj,uBias),HX_("uBias",8e,f5,d1,89)},
	{hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(ConvolutionShader_obj,uConvoMatrix),HX_("uConvoMatrix",27,06,24,20)},
	{hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(ConvolutionShader_obj,uDivisor),HX_("uDivisor",69,15,42,62)},
	{hx::fsObject /*  ::openfl::display::ShaderParameter_Bool */ ,(int)offsetof(ConvolutionShader_obj,uPreserveAlpha),HX_("uPreserveAlpha",3d,d2,3a,39)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *ConvolutionShader_obj_sStaticStorageInfo = 0;
#endif

static ::String ConvolutionShader_obj_sMemberFields[] = {
	HX_("uBias",8e,f5,d1,89),
	HX_("uConvoMatrix",27,06,24,20),
	HX_("uDivisor",69,15,42,62),
	HX_("uPreserveAlpha",3d,d2,3a,39),
	::String(null()) };

hx::Class ConvolutionShader_obj::__mClass;

void ConvolutionShader_obj::__register()
{
	ConvolutionShader_obj _hx_dummy;
	ConvolutionShader_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("openfl.filters._ConvolutionFilter.ConvolutionShader",51,6d,41,f8);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(ConvolutionShader_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< ConvolutionShader_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ConvolutionShader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ConvolutionShader_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace filters
} // end namespace _ConvolutionFilter
